<!DOCTYPE html>
<html>
<head>
  <title>Stylus Input to Canvas</title>
	<link rel="stylesheet" href="style.css">

</head>
<body>
<p id=type>---</p>
<p id=pensize>---</p>
<p id=len>---</p>
  <canvas id="canvas"></canvas>
  <script>
    const canvas = document.getElementById('canvas');
    canvas.width = document.body.offsetWidth;
    canvas.height = document.body.offsetHeight;
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = true;
    ctx.translate(0.5, 0.5);
    let currentPath = [];
    let currentColor = 'black';
    let mouseIsDown = false;
    let penIsDown = false;
    
    //canvas.addEventListener('mousedown', startDrawing);
    //canvas.addEventListener('mousemove', draw);
    //canvas.addEventListener('mouseup', endDrawing);
    //canvas.addEventListener('touchstart', startDrawingTouch);
    //canvas.addEventListener('touchmove' , drawTouch);
    //canvas.addEventListener('touchup' , endDrawingTouch);
    //canvas.addEventListener('pointerdown' , startDrawingTouch);
    canvas.addEventListener('pointermove' , drawTouch);
    //canvas.addEventListener('pointerup' , endDrawingTouch);
    
    
    function processPointer(event)
    {
    document.getElementById("pensize").innerHTML = event.pressure;
    /*
    if (event.pressure === 0) {
      // No pressure
      process_no_pressure(event);
    } else if (event.pressure === 1) {
      // Maximum pressure
      process_max_pressure(event);
    } else {
      // Default
      process_pressure(event);
    }
    */
  }
    
    function startDrawing(event) {
      if (event.button === 0  // left button
         || event.targetTouches[0].radiusX === 0) {
          document.getElementById("pensize").innerHTML = "mousedraw";
        currentPath = [];
        mouseIsDown = true;
      }
    }
    
    function draw(event) {
      if (mouseIsDown) {
        const point = { 
          x: event.offsetX, 
          y: event.offsetY, 
          pressure: event.pressure 
        };
        currentPath.push(point);
        drawPath();
      }
    }
    
    function endDrawing(event) {
      if (event.button === 0 // left button
         || event.targetTouches[0].radiusX === 0) {

        mouseIsDown = false;
        writePathToCanvas();
      }
    }
    
    
    
    function startDrawingTouch(event) {
      //if (event.targetTouches[0].radiusX === 0 || true) {
      //   if (event.targetTouches.length>0)
      //    document.getElementById("pensize").innerHTML = event.targetTouches[0].radiusX;
      //   else
          document.getElementById("pensize").innerHTML = "pendown";
        currentPath = [];
        penIsDown = true;
     // }
    }
    
    function drawTouch(event) {
      if (event.pressure < 1.0) {
        const point = { 
          x: event.offsetX, 
          y: event.offsetY, 
          pressure: event.pressure 
        };
     //    if (event.targetTouches.length>0)
          document.getElementById("pensize").innerHTML = event.pressure;
          document.getElementById("len").innerHTML = currentPath.length;
          document.getElementById("type").innerHTML = event.pointerType;
      //   else
       //   document.getElementById("pensize").innerHTML = "no target touch radius -> no evaluation of pressure";
       if(event.pressure > 0.001)
       {
        currentPath.push(point);
        drawPath();
        }
        else{
        currentPath=[];
        }
     }
    }
    
    function endDrawingTouch(event) {
    //  if (event.targetTouches[0].radiusX === 0 || true) {
	document.getElementById("pensize").innerHTML = "pen up";
        penIsDown = false;
        drawPath();
        //writePathToCanvas();
     // }
    }
    /*
    function writePathToCanvas() {
      if (currentPath.length > 1) {
        ctx.strokeStyle = currentColor;
        ctx.beginPath();
        ctx.moveTo(currentPath[0].x, currentPath[0].y);
        for (let i = 1; i < currentPath.length; i++) {
          const point = currentPath[i];
          ctx.lineWidth = point.pressure * 20;
          ctx.lineTo(point.x, point.y);
        }
        ctx.stroke();
      }
    }
    */
    function drawPath() {
     // ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (currentPath.length > 1) {
        ctx.strokeStyle = currentColor;
        ctx.fillStyle = currentColor;
        //ctx.lineWidth = currentPath[0].pressure * 20;
        /*
        for (let i = 1; i < currentPath.length; i++) {
          const point = currentPath[i];
          ctx.beginPath();
          ctx.moveTo(currentPath[i-1].x, currentPath[i-1].y);
          ctx.lineWidth = point.pressure * 20;
          ctx.lineTo(point.x, point.y);
          ctx.stroke();
        }
        */
        
        const widthFactor = 2;
        const minWidth = 0.5;
        let lastNormal = {x:0,y:0};
	ctx.beginPath();
	  ctx.moveTo(currentPath[0].x, currentPath[0].y);
          ctx.lineTo(currentPath[1].x+currentPath[1].pressure*widthFactor, currentPath[1].y+currentPath[1].pressure*widthFactor);
        for (let i = 2; i < currentPath.length; i++) {
          const point = currentPath[i];
          const width = Math.sqrt(point.pressure) * widthFactor + minWidth;
          //ctx.moveTo(currentPath[i-1].x+width, currentPath[i-1].y+width);
          let dx = currentPath[i-1].x - point.x; 
          let dy = currentPath[i-1].y - point.y
          let len = Math.sqrt(dx*dx+dy*dy);
          if(len===0) len = 1;
          let normal = {x: -dy/len + lastNormal.x/2, y: dx/len  + lastNormal.y/2};
          lastNormal = normal;
          ctx.lineTo(point.x+width*normal.x, point.y+width*normal.y);
        }
        const l = currentPath.length-1;
        //ctx.moveTo(currentPath[l].x+currentPath[l].pressure*widthFactor, currentPath[l].y+currentPath[l].pressure*widthFactor);
          ctx.lineTo(currentPath[l].x-currentPath[l].pressure*widthFactor, currentPath[l].y-currentPath[l].pressure*widthFactor);
        for (let i = currentPath.length-1; i > 1; i--) {
          const point = currentPath[i];
          const width = Math.sqrt(point.pressure) * widthFactor + minWidth;
          //ctx.moveTo(currentPath[i-1].x-width, currentPath[i-1].y-width);
          let dx = currentPath[i-1].x - point.x; 
          let dy = currentPath[i-1].y - point.y
          let len = Math.sqrt(dx*dx+dy*dy);
          if(len===0) len = 1;
          let normal = {x: -dy/len, y: dx/len};
          ctx.lineTo(point.x-width*normal.x, point.y-width*normal.y);
        }        
	  //ctx.moveTo(currentPath[1].x-currentPath[1].pressure*widthFactor, currentPath[1].y-currentPath[1].pressure*widthFactor);
          ctx.lineTo(currentPath[0].x, currentPath[0].y);
          ctx.closePath();
        ctx.fill();
      }
    }
    
    
    /*
    var drawSmoothLine = function(surf, ctrl_points){
    var l = ctrl_points.length;
    switch (l){
    case 0:
    case 1: //no control points
        break;
    case 2: //line
        surf.beginPath();
        surf.moveTo(ctrl_points[0].x, ctrl_points[0].y);
        surf.lineTo(ctrl_points[1].x, ctrl_points[1].y);
        surf.stroke();
        break;
    case 3: //lets use the second point as the two middle control points
        surf.beginPath();
        surf.moveTo(ctrl_points[0].x, ctrl_points[0].y);
        surf.bezierCurveTo(ctrl_points[1].x, ctrl_points[1].y, ctrl_points[1].x, ctrl_points[1].y, ctrl_points[2].x, ctrl_points[2].y);
        surf.stroke();
        break;
    default: //lets draw a bezier with the first 4 points, and for the rest lets create a control point to keep the line smooth
        surf.beginPath();
        surf.moveTo(ctrl_points[0].x, ctrl_points[0].y);
        var pnt_a = ctrl_points[1], pnt_b = ctrl_points[2], pnt_end = ctrl_points[3];
        surf.bezierCurveTo(pnt_a.x, pnt_a.y, pnt_b.x, pnt_b.y, pnt_end.x, pnt_end.y);
        ctrl_points = ctrl_points.slice(0);
        l = ctrl_points.length;
        pnt_b = ctrl_points[2];
        var i = 5
        for (; i < l; i += 2){
            pnt_a = {x: pnt_end.x + (pnt_end.x - pnt_b.x), y: pnt_end.y + (pnt_end.y - pnt_b.y)};
            pnt_b = ctrl_points[i - 1];
            pnt_end = ctrl_points[i];
            surf.bezierCurveTo(pnt_a.x, pnt_a.y, pnt_b.x, pnt_b.y, pnt_end.x, pnt_end.y);
        }
        if (i == l){ //a last lonely point, lets use the calculated pnt_a as pnt_b
            pnt_a = {x: pnt_end.x + (pnt_end.x - pnt_b.x), y: pnt_end.y + (pnt_end.y - pnt_b.y)};
            pnt_b = pnt_a;
            pnt_end = ctrl_points[l - 1];
            surf.bezierCurveTo(pnt_a.x, pnt_a.y, pnt_b.x, pnt_b.y, pnt_end.x, pnt_end.y);
        }
        surf.stroke();
        break;
    }
};
*/
  </script>
</body>
</html>

